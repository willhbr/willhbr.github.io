---
title: "Add a Signature to Your Website"
tags: web
---

Nothing says "sophisticated and refined" like putting your signature at the bottom of your blog posts. However if you don't do it right, you might end up with pixellated garbage, and that's not refined at all. I've just done this (have a look at the bottom of this post) and there are a few tricks to get this working nicely.

First thing is to get a signature. I didn't want to use the unintelligable scrawl I leave on important documents, but instead put a little more emphasis on my domain nameâ€”it's my name and initials.

I used my iPad and [GoodNotes](https://www.goodnotes.com) to sign over and over again until I had one I was happy with. You could of course do this with pen and paper, the key is to just use a writing implement that leaves a stroke with uniform width and darkness. GoodNotes is great for this because it has my favourite pen mode: "the best fine-point felt-tip pen you've ever used". We're going to be converting this to an SVG later, and my SVG-ing skills can't handle variable width strokes, so the uniform width is key.

There's probably some way to get an SVG out of GoodNotes, but like so many things on iPadOS you'll fight the implicit conversion to an raster image at some point in the process anyway. I just selected the good signature and copied it to the [universal clipboard](https://support.apple.com/en-us/102430) so I could paste it into [Pixelmator Pro](https://www.pixelmator.com/pro/) on my laptop.

At this point you could just save the signature as a PNG, slap it on your website, and call it a day. But we can do better.

There's probably some nice tool to convert an image to clean vector shapes, but I opted to just trace it manually. I used the "freeform pen" tool in Pixelmator, this is a standard tool in any image editor with vector features, it lets you draw a shape freehand and have the result be a bezier curve.

I traced over each stroke in the signature really badly using the trackpad. It would've been easier with a mouse but I didn't want to get off the couch. The quality of the first pass isn't really important, as you've got to go over each stroke and use the vector control nubs to get it as close as possible to the original signature. Here you could have a little artistic license and smooth out some curves or other imperfections.

Now we've got an SVG, which we could totally just put on our website and appreciate the infinite scalability, but it's not quite that simple.

The first trap is that if you export as SVG from Pixelmator Pro it will do the completely reasonable thing of including all your raster layers as `<image>` tags with base64 encoded data (even if they're hidden). My exported SVG was 137kB, which is huge.

You could delete them manually but there's a better way: [SVGO](https://svgo.dev). It's an SVG optimiser, which shrinks the size of SVGs by combining paths and removing unnecessary data. I have no idea how it works, it seems like magic to me. This is the original SVG (with data omitted for readability):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by Pixelmator Pro 3.7.1 -->
<svg width="1364" height="486" viewBox="0 0 1364 486"
  xmlns="http://www.w3.org/2000/svg"
  xmlns:xlink="http://www.w3.org/1999/xlink">
    <path id="Path" fill="none" stroke="#000"
      stroke-width="25" stroke-linecap="round"
      stroke-linejoin="round" d="..."/>
    <path id="path1" fill="none" stroke="#000"
      stroke-width="25" stroke-linecap="round"
      stroke-linejoin="round" d="..."/>
    <path id="path2" fill="none" stroke="#000"
      stroke-width="25" stroke-linecap="round"
      stroke-linejoin="round" d="..."/>
    <path id="path3" fill="none" stroke="#000"
      stroke-width="25" stroke-linecap="round"
      stroke-linejoin="round" d="..."/>
    <path id="path4" fill="none" stroke="#000"
      stroke-width="25" stroke-linecap="round"
      stroke-linejoin="round" d="..."/>
    <path id="path5" fill="none" stroke="#000"
      stroke-width="25" stroke-linecap="round"
      stroke-linejoin="round" d="..."/>
    <path id="path6" fill="none" stroke="#000"
      stroke-width="25" stroke-linecap="round"
      stroke-linejoin="round" d="..."/>
    <path id="path7" fill="none" stroke="#000"
      stroke-width="25" stroke-linecap="round"
      stroke-linejoin="round" d="..."/>
    <path id="path8" fill="none" stroke="#000"
      stroke-width="25" stroke-linecap="round"
      stroke-linejoin="round" d="..."/>
    <path id="path9" fill="none" stroke="#000"
      stroke-width="25" stroke-linecap="round"
      stroke-linejoin="round" d="..."/>
    <path id="path10" fill="none" stroke="#000"
      stroke-width="25" stroke-linecap="round"
      stroke-linejoin="round" d="..."/>
    <image id="Layer" x="2" y="-1" width="1364"
      height="490" visibility="hidden"
      xlink:href="data:image/png;base64, ..."/>
</svg>
```

Then here's the optimised SVG (again with data omitted):

```xml
<svg xmlns="http://www.w3.org/2000/svg" width="1364"
  height="486" viewBox="0 0 1364 486">
  <path fill="none" stroke="#000" stroke-linecap="round"
    stroke-linejoin="round" stroke-width="25" d="..."/>
  <path fill="none" stroke="#000" stroke-linecap="round"
    stroke-linejoin="round" stroke-width="25" d="..."/>
  <path fill="none" stroke="#000" stroke-linecap="round"
    stroke-linejoin="round" stroke-width="25" d="..."/>
  <path fill="none" stroke="#000" stroke-linecap="round"
    stroke-linejoin="round" stroke-width="25" d="..."/>
</svg>
```

It removed the invisible image (I would have done that manually anyway) but it also decided I only needed four `<path>` tags, removed the comment, and removed a _tonne_ of point data from the actual paths. The original file was 137kB, removing the `<image>` takes that to 4.6kB (totally reasonable SVG size), then SVGO cuts that in half to 2.4kB. With no difference that I can see.

We can then put the SVG on our website and marvel at the small file size and resolution-independence. However, there's a tradeoff: if we embed the SVG directly into the page with an `<svg>` tag, it can be styled by the site's CSS rules and thus respond to light and dark mode, but that will increase the size of every HTML page by 2.4kB. If it's included with an `<img>` tag it'll be loaded once and cached, but it can't access styles.

My site has both light and dark themes, so the signature needs to respond to the CSS, but I also don't want a 2.4kB increase on every page.[^dont-ask] Thankfully we can get the best of both worlds.

[^dont-ask]: Don't ask why I insist on minimising the size of my site but I'm happy serving four web fonts.

The trick is to use the SVG as an [`mask-image`][mask-image] for an element that has the `background-color` we want the stroke of our SVG to be. This only works for monochrome images (without much more complicated trickery) which is perfect for this use case. On the page we just need a placeholder element:

[mask-image]: https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/mask-image

```html
<div id="signature"></div>
```

Then in CSS (or in my case, SASS) we set the `mask-image` and some other `mask-` properties to ensure we only get a single, correctly-sized signature.

```sass
#signature
  mask-image: url("/images/signature.svg")
  mask-size: contain
  mask-repeat: no-repeat
  mask-position: center
  background: $text-colour
  height: 3em
```

The `<div>` placeholder will change colour between light mode and dark mode, only visible through the `mask-image`, giving the impression that the SVG is able to change colour, without wasting 2.4kB on every page.

Related, I really like this [introduction to SVG](https://www.joshwcomeau.com/svg/friendly-introduction-to-svg/) which really shows off how much more you can do with it. That's what made me choose SVG for the graph in [_Light Mode InFFFFFFlation_](/2025/10/20/light-mode-infffffflation/).
